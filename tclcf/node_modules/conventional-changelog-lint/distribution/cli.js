#!/usr/bin/env node
'use strict';

// Assemble the engine

let main = function () {
	var ref = _asyncToGenerator(function* (options) {
		const raw = options.input;
		const flags = options.flags;

		const fromStdin = rules.fromStdin(raw, flags);

		const input = fromStdin ? [yield (0, _getStdin2.default)()] : yield (0, _.getMessages)((0, _lodash.pick)(flags, 'edit', 'from', 'to'));

		return Promise.all(input.map((() => {
			var ref = _asyncToGenerator(function* (commit) {
				const fmt = new _chalk2.default.constructor({ enabled: flags.color });

				const seed = {};
				if (flags.extends) {
					seed.extends = flags.extends.split(',');
				}

				const report = yield (0, _2.default)(commit, {
					preset: yield (0, _.getPreset)(flags.preset),
					configuration: yield (0, _.getConfiguration)('conventional-changelog-lint', {
						prefix: 'conventional-changelog-lint-config'
					}, seed)
				});

				const formatted = (0, _.format)(report, {
					color: flags.color,
					signs: [' ', 'âš ', 'âœ–'],
					colors: ['white', 'yellow', 'red']
				});

				if (!flags.quiet) {
					console.log(`${ fmt.grey('â§—') }   input: ${ fmt.bold(commit.split('\n')[0]) }`);
					console.log(formatted.join('\n'));
				}

				if (report.errors.length > 0) {
					const error = new Error(formatted[formatted.length - 1]);
					error.type = _package2.default.name;
					throw error;
				}

				return console.log('');
			}),
			    _this = this;

			return function (_x2) {
				return ref.apply(_this, arguments);
			};
		})()));
	});

	return function main(_x) {
		return ref.apply(this, arguments);
	};
}();

// Start the engine


require('babel-polyfill');

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _meow = require('meow');

var _meow2 = _interopRequireDefault(_meow);

var _lodash = require('lodash');

var _getStdin = require('get-stdin');

var _getStdin2 = _interopRequireDefault(_getStdin);

var _help = require('./help');

var _help2 = _interopRequireDefault(_help);

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _package = require('../package');

var _package2 = _interopRequireDefault(_package);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
// polyfills


// npm modules


// local modules


/**
 * Behavioural rules
 */
const rules = {
	fromStdin: (input, flags) => input.length === 0 && flags.from === null && flags.to === null && !flags.edit
};

const configuration = {
	// flags of string type
	string: ['from', 'to', 'preset', 'extends'],
	// flags of array type
	// flags of bool type
	boolean: ['edit', 'help', 'version', 'quiet', 'color'],
	// flag aliases
	alias: {
		c: 'color',
		e: 'edit',
		f: 'from',
		p: 'preset',
		t: 'to',
		q: 'quiet',
		h: 'help',
		v: 'version',
		x: 'extends'
	},
	description: {
		color: 'toggle formatted output',
		edit: 'read last commit message found in ./git/COMMIT_EDITMSG',
		extends: 'array of shareable configurations to extend',
		from: 'lower end of the commit range to lint; applies if edit=false',
		preset: 'conventional-changelog-preset to use for commit message parsing',
		to: 'upper end of the commit range to lint; applies if edit=false',
		quiet: 'toggle console output'
	},
	// flag defaults
	default: {
		color: true,
		edit: false,
		from: null,
		preset: 'angular',
		to: null,
		quiet: false
	},
	// fail on unknown
	unknown(arg) {
		throw new Error(`unknown flags: ${ arg }`);
	}
};

// Init meow ðŸ˜¸cli
const cli = (0, _meow2.default)({
	help: `[input] reads from stdin if --edit, --from, --to are omitted\n${ (0, _help2.default)(configuration) }`,
	description: `${ _package2.default.name }@${ _package2.default.version } - ${ _package2.default.description }`
}, configuration);main(cli).catch(error => setTimeout(() => {
	if (error.type === _package2.default.name) {
		process.exit(1);
	}
	throw error;
}));

// Catch unhandled rejections globally
process.on('unhandledRejection', (reason, promise) => {
	console.log('Unhandled Rejection at: Promise ', promise, ' reason: ', reason);
	throw reason;
});