module.exports = function(gulp, config, done) {
    var AWS = require('aws-sdk')
    var awspublish = require('gulp-awspublish')
    var gitrev = require('git-rev')
    var fs = require('fs-extra')
    var gutil = require('gulp-util')
    var _ = require('lodash')
    var async = require('async')
    
    var accessKeyId = process.env.AWS_ACCESS_KEY
    var secretAccessKey = process.env.AWS_SECRET_KEY
    var project = fs.readJsonSync('./package.json')
    var environments = project.environments || {}
    var bucket = process.argv.reduce((output, arg, index) => {
        if (arg === '--bucket') {
            output.index = index + 1
        } else if (index === output.index) {
            output.value = arg
        }
        return output
    }, {value: environments.dev || `${project.name}-dev.connectedfleet.io`}).value

    var s3 = new AWS.S3({
        accessKeyId: accessKeyId,
        secretAccessKey: secretAccessKey
    })

    var createEnvironmentsFile = function(callback) {
        var file = `${config.stage}/env.json`
        fs.writeJson(file, environments, callback)
    }

    var deleteFile = function(s3bucket, key, callback) {
        s3.deleteObject({
            Bucket: s3bucket, Key: key
        }, function(err, data) {
            if (err) {
                gutil.log(gutil.colors.red(`Unable to delete ${key} from ${s3bucket}`), err)
                callback(err, null)
            } else {
                callback(null, data)
            }
        })
    }

    var emptyBucket = function(callback) {
        s3.listObjects({Bucket: bucket}, function(err, data) {
            if (err) {
                gutil.log(gutil.colors.red(err), err)
                callback(err)
            } else {
                var deleteFunctions = _.map(_.map(data.Contents, 'Key'), function(key) {
                    return function(cb) {
                        gutil.log(gutil.colors.yellow(`deleting ${key} from ${bucket}`))
                        deleteFile(bucket, key, cb)
                    }
                })
                async.parallel(deleteFunctions, function(deleteErr) {
                    if (deleteErr) {
                        // not a fatal error. Log it and move on
                        gutil.log(gutil.colors.red('Error cleaning out S3 Bucket'), deleteErr)
                    }
                    callback()
                })
            }
        })
    }

    var publish = function() {
        var publisher = awspublish.create({
            params: {
                Bucket: bucket
            },
            accessKeyId: accessKeyId,
            secretAccessKey: secretAccessKey
        })

        gulp.src(`${config.stage}/**/*`)
            .pipe(publisher.publish([], {options: {force: true}}))
            .pipe(publisher.publish())
            .pipe(awspublish.reporter())

        gitrev.short(function(sha) {
            gutil.log(gutil.colors.yellow('Using sha:'), sha)
            gutil.log(gutil.colors.yellow('Using bucket:'), bucket)

            var index = `index.${sha}.html`
            gutil.log(gutil.colors.yellow('Using index:'), index)

            var params = {
                Bucket: bucket,
                WebsiteConfiguration: {
                    IndexDocument: {
                        Suffix: index
                    }
                }
            }

            s3.putBucketWebsite(params, function(err) {
                if (err) {
                    gutil.log(gutil.colors.red(err), err)
                }
            })

            var cloudfront = new AWS.CloudFront({
                accessKeyId: accessKeyId,
                secretAccessKey: secretAccessKey
            })

            cloudfront.listDistributions({}, function(distributionErr, distributionData) {
                gutil.log(gutil.colors.yellow(`Updating CloudFront to use new root document: ${index}`))
                if (distributionErr) {
                    gutil.log(gutil.colors.red('Error getting distribution from CloudFront'), distributionErr)
                } else {
                    var distribution = _.find(distributionData.Items, function(item) {
                        return _.includes(_.get(item, 'Origins.Items[0].Id'), `${project.name}-dev`)
                    })

                    if (!distribution) {
                        gutil.log(gutil.colors.red('unable to find suitable CloudFront distribution to update'))
                        return
                    }

                    cloudfront.getDistribution({Id: distribution.Id}, function(err, data) {
                        if (err || !data) {
                            gutil.log(gutil.colors.red('unable to load CloudFront distribution to update'))
                            return
                        }

                        var eTag = data.ETag
                        var distributionConfig = data.Distribution.DistributionConfig
                        distributionConfig.DefaultRootObject = index

                        var updateParams = {
                            DistributionConfig: distributionConfig,
                            Id: distribution.Id,
                            IfMatch: eTag
                        }

                        cloudfront.updateDistribution(updateParams, function(updateErr) {
                            if (updateErr) {
                                gutil.log(gutil.colors.red('unable to update CloudFront distribution'), updateErr)
                            }
                        })
                    })
                }
            })
        })
    }

    var publishPrep = function(cb) {
        async.parallel([createEnvironmentsFile, emptyBucket], function(err) {
            cb(err)
        })
    }

    async.series([publishPrep, publish], function(err) {
        if (err) {
            gutil.log(gutil.colors.red('An error occurred during publish'), err)
        }
        gutil.log('Publish completed')
    })

    done()
}
