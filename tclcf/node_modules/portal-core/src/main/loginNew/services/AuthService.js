let _ = require('lodash')

module.exports = class AuthService {
    /* @ngInject */
    constructor($analytics, $log, $q, $location, $rootScope, auth0Lock, authConfig, i18nService,
                Restangular, titleService, toastService, tokenService) {
        this.$analytics = $analytics
        this.$log = $log
        this.$q = $q
        this.$location = $location
        this.$rootScope = $rootScope
        this.i18nService = i18nService
        this.Restangular = Restangular
        this.auth0Lock = auth0Lock
        this.authConfig = authConfig
        //TODO: depend on this from the App component when it exists instead of here
        this.titleService = titleService
        this.toastService = toastService
        this.tokenService = tokenService

        //initialize
        this.currentUser = null
        this.userDefer = this.$q.defer()
        this.deferResolved = false
        this.redirectUrl = null
    }
    
    isLoggedIn() {
        return !!this.currentUser && !this.currentUser.anonymous
    }

    getCurrentUser() {
        return this.userDefer.promise
    }

    login(forceRedirect) {
        return new this.$q((resolve, reject) => {
            let options = {
                disableSignupAction: true,
                rememberLastLogin: false,
                gravatar: false,
                closable: !this.authConfig.requireLogin
            }

            //show the login form
            this.auth0Lock.show(options, (err, profile, token) => {
                if (err) {
                    this.$log.error('Login error:', err)
                    return reject(err)
                }

                return this.Restangular.all('getIdToken').customPOST({encodedToken: token}, '')
                    .then(response => {
                        this.tokenService.updateTokens(response)
                        this.$rootScope.$broadcast('login')
                        return this.tokenUpdated(response.idToken, this.authConfig.requireLogin || forceRedirect)
                    })
                    .then(user => resolve(user))
                    .catch(loginErr => {
                        let msg = _.get(loginErr, 'data.rejectReason',
                            'An error has occured. Please check your connection and try again.')
                        this.toastService.show(msg, {theme: 'warn'})

                        this.$analytics.eventTrack('Failed Login', {category: 'Security', label: loginErr.status})
                        this.$log.error('Login error:', loginErr)
                        reject(loginErr)
                    })
            })

            //handle when user closes without logging in
            this.auth0Lock.once('close', () => reject('Login cancelled'))
        })
    }

    logout() {
        //save old url for redirect later
        this.redirectUrl = this.$location.url()

        this.$rootScope.$broadcast('logout')
        this.userDefer = this.$q.defer()
        this.deferResolved = false
        this.setUser()
        this.tokenService.clear()

        return this.$q.resolve({})
    }

    setUser(user) {
        if (this.deferResolved) {
            this.userDefer = this.$q.defer()
            this.deferResolved = false
        }

        if (user) {
            this.currentUser = user
            this.userDefer.resolve(this.currentUser)
            this.deferResolved = true
        } else if (this.authConfig.requireLogin) {
            this.currentUser = null
        } else {
            this.currentUser = {
                firstName: 'Guest',
                anonymous: true,
                getTagByKey: () => '',
                hasPermission: perm => /ANONYMOUS/i.test(perm)
            }
            this.userDefer.resolve(this.currentUser)
            this.deferResolved = true
        }
    }

    refreshTokens() {
        return this.Restangular.all('refreshToken').customPOST({
            encodedToken: this.tokenService.getEncodedToken()
        }).then(tokens => {
            this.tokenService.updateTokens(tokens)
            return this.tokenUpdated(tokens.idToken)
        }).catch(err => {
            this.$log.error('Error refreshing tokens', err)
            this.logout()
            return this.$q.reject(err)
        })
    }

    tokenUpdated(token, redirect) {
        let curUrl = this.$location.url()
        if (token) {
            return this.Restangular.all('users', 'id').get(token.uid)
                .then(user => {
                    return user.locale ? this.$q.resolve(user) : user.setLocale(this.i18nService.getBrowserLocale())
                })
                .then(user => {
                    this.setUser(_.merge(user, token))

                    //add fake permission to indicate user is authenticated
                    this.currentUser.grant.push('AUTHENTICATED')

                    return this.currentUser
                })
                .then(user => this.i18nService.updateCurrentLocale(user))
                .then(user => {
                    if (redirect && this.authConfig.requireLogin && !_.startsWith(curUrl, '/nav/')) {
                        this.$location.url(this.redirectUrl || '/nav/welcome')
                        this.redirectUrl = null
                    }
                    return user
                })
        } else if (this.authConfig.requireLogin) {
            if (!curUrl || _.startsWith(curUrl, '/nav/')) {
                this.redirectUrl = curUrl
                this.$location.url('/login')
            }
            return this.$q.reject('No user token found.')
        } else {
            this.setUser()
            return this.$q.resolve(this.currentUser)
        }
    }
}
