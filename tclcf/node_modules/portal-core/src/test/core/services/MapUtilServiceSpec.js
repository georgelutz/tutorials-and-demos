const proxyquire = require('proxyquire').noCallThru()

describe('MapUtilService', () => {
    let svc
    let mapApiKey
    let $mdDialog
    let $q
    let $http
    let MapDialog

    beforeEach(() => {
        $q = {}
        $mdDialog = {}
        $http = {}
        MapDialog = {}

        mapApiKey = 'mapApiKey'

        let MapUtilService = proxyquire('../../../main/core/services/MapUtilService', {
            '../components/MapDialog': MapDialog
        })
        svc = new MapUtilService(mapApiKey, $mdDialog, $q, $http)
    })

    it('should calculate the distance between two lat1, lon1, lat2, lon2', () => {
        let lat1 = 45.14851000000001
        let lon1 = -95.82736
        let lat2 = 45.831335
        let lon2 = -95.383322

        let distanceBetweenTwoPoints = svc.distance(lat1, lon1, lat2, lon2)

        distanceBetweenTwoPoints.should.equal('51.8 Miles')
    })

    it('should return the correct map url', () => {
        // given an expected map size and a location
        let lat = 456
        let lon = 123
        let scale = 0.05
        let returnedMapUrl

        // when getMapUrl is called
        returnedMapUrl = svc.getMapUrl(lat, lon, scale)

        // then the correct url should be returned
        returnedMapUrl.should.equal('https://pcmiler.alk.com/APIs/REST/v1.0/Service.svc/map?AuthToken=mapApiKey&' +
            'pt1=123.05,456.05&pt2=122.95,455.95&pins=123,456&drawergroups=Cities,Labels,Roads,Commercial,' +
            'Borders,Areas&srs=EPSG:4326&region=NA&dataset=Current&init=true&imgOption=Both&width=300&height=300')
    })

    it('should support geocoding', () => {
        let response = {
            data: [
                {
                    Coords: {
                        Lon: 123,
                        Lat: 456
                    }
                }
            ]
        }
        $http.get = sinon.stub().resolves(response)

        return svc.geocode('a', 'b', 'c', 'd')
            .then(result => {
                result.should.deep.equal({
                    lon: 123,
                    lat: 456
                })
                $http.get.should.have.been.calledWith('https://pcmiler.alk.com/APIs/REST/v1.0/service.svc/locations?' +
                    'AuthToken=mapApiKey&list=1&region=4&dataset=Current&street=a&city=b&state=c&postcode=d')
            })
    })

    it('should support reverse geocoding', () => {
        let response = {
            data: [
                {
                    Address: {
                        StreetAddress: 'a',
                        City: 'c',
                        Country: 'o',
                        State: 's',
                        Zip: 'z',
                        misc: 'stuff',
                        blah: 'whatever'
                    }
                }
            ]
        }
        $http.get = sinon.stub().resolves(response)

        return svc.reverseGeocode(123, 456)
            .then(result => {
                result.should.deep.equal({
                    streetAddress: 'a',
                    city: 'c',
                    country: 'o',
                    state: 's',
                    zipcode: 'z'
                })
                $http.get.should.have.been.calledWith('https://pcmiler.alk.com/APIs/REST/v1.0/service.svc/locations?' +
                    'AuthToken=mapApiKey&region=4&dataset=Current&coords=123,456')
            })
    })

    it('should show popups', () => {
        let event = {event: true}
        $mdDialog.show = sinon.stub().resolves({})
        let map = {destroy: sinon.stub()}
        let promise = Promise.resolve(map)
        let defer = {
            promise: promise
        }
        $q.defer = sinon.stub().returns(defer)

        return svc.showMapPopup(event)
            .then(() => {
                $mdDialog.show.should.have.been.calledWith({
                    targetEvent: event,
                    locals: {
                        defer: defer
                    }
                })
            })
    })
    it('should support geocoding when data is empty', () => {
        let emptyaddress = (null, null, null, null)
        return svc.geocode(emptyaddress)
            .then(result => {
                should.not.exist(result)
            })
    })
})
