describe('SearchService', () => {
    let init
    let Restangular
    let response
    let response1
    let response2
    let globalSearch
    let $state
    let svc
    let searchItem1
    let searchItem2
    let globalSearchFunction1
    let globalSearchFunction2
    let $q
    let $log
    let term
    let searchEntities
    let params
    let authService

    beforeEach(() => {
        Restangular = {}
        term = 'termy'

        searchItem1 = {
            type: 'entity',
            listRoute: 'list.route1',
            responseHandler: sinon.stub(),
            selectHandler: sinon.stub(),
            typeTranslationKey: 'typeTranslationKey'
        }
        searchItem2 = {
            type: 'entity2',
            listRoute: 'list.route2',
            responseHandler: sinon.stub(),
            selectHandler: sinon.stub(),
            typeTranslationKey: 'typeTranslationKey'
        }

        response = {
            entity: {
                data: searchItem1,
                responseDescription: {
                    pageSize: 0,
                    page: 0,
                    totalHits: 0
                }
            },
            entity2: {
                data: searchItem2,
                responseDescription: {
                    pageSize: 0,
                    page: 0,
                    totalHits: 0
                }
            }
        }

        response1 = {
            entity: {
                data: searchItem1,
                responseDescription: {
                    pageSize: 0,
                    page: 0,
                    totalHits: 0
                }
            }
        }

        response2 = {
            entity2: {
                data: searchItem2,
                responseDescription: {
                    pageSize: 0,
                    page: 0,
                    totalHits: 0
                }
            }
        }

        globalSearchFunction1 = sinon.stub().resolves(response1)
        globalSearchFunction2 = sinon.stub().resolves(response2)

        globalSearch = {
            searchItems: [searchItem1, searchItem2],
            searchFunctions: [{inputType: '1', function: globalSearchFunction1},
                {inputType: '2', function: globalSearchFunction2}]
        }

        $state = {}

        $q = Promise

        $log = {}

        searchEntities = _.map(globalSearch.searchItems, 'type')
        params = {
            q: term,
            page: 0,
            pageSize: 5,
            globalsearch: true,
            entities: searchEntities
        }

        let SearchService = require('../../../main/core/services/SearchService')
        init = () => {
            return new SearchService($log, $q, $state, authService, globalSearch, Restangular)
        }
        svc = init()
    })

    it('should support typeahead search', () => {
        let processed1 = [{blah: '11'}, {blah: '12'}]
        let processed2 = [{blah: '21'}, {blah: '22'}]
        searchItem1.responseHandler.withArgs(response, 'myContext').returns(processed1)
        searchItem2.responseHandler.withArgs(response, 'myContext').returns(processed2)

        return svc.typeAheadSearch(term, null, 'myContext')
            .then(result => {
                result.should.deep.equal([
                    {blah: '11', term: 'termy'},
                    {blah: '12', term: 'termy'},
                    {blah: '21', term: 'termy'},
                    {blah: '22', term: 'termy'}
                ])
                globalSearchFunction1.should.have.been.calledWith($log, authService, Restangular, params)
                globalSearchFunction2.should.have.been.calledWith($log, authService, Restangular, params)
            })
    })

    it('should support handle selection', () => {
        //given some mocks
        searchItem1.selectHandler.returns(false)
        searchItem2.selectHandler.returns(true)
        let value = 'abc'

        //when called
        svc.handleSelection(value).should.be.true

        //it should call the select handlers
        searchItem1.selectHandler.should.have.been.calledWith(value, $state)
        searchItem2.selectHandler.should.have.been.calledWith(value, $state)
    })

    it('should support term search', () => {
        //given some mocks and multiple response entities
        let processed1 = [{type: 'entity', icon: 'icon1'}, {type: 'entity', icon: 'icon1'}]
        let processed2 = [{type: 'entity2', icon: 'icon2'}, {type: 'entity2', icon: 'icon2'}]

        response.entity2.responseDescription.totalHits = 123
        response.entity.responseDescription.totalHits = 123
        response1.entity.responseDescription.totalHits = 123
        response2.entity2.responseDescription.totalHits = 123

        let responseArg2 = _.cloneDeep(response)
        responseArg2.entity.icon = 'icon1'

        // and a response with the expected properties added
        let expectedResponse = _.cloneDeep(response)
        expectedResponse.entity.icon = 'icon1'
        expectedResponse.entity2.icon = 'icon2'

        searchItem1.responseHandler.withArgs(response).returns(processed1)
        searchItem2.responseHandler.withArgs(responseArg2).returns(processed2)


        //when called with lots of responses
        return svc.termSearch(term)
            .then(result => {
                globalSearchFunction1.should.have.been.calledWith($log, authService, Restangular, params)
                globalSearchFunction2.should.have.been.calledWith($log, authService, Restangular, params)

                //then the result with updates should be returned
                result.should.deep.equal(expectedResponse)
            })
    })

    it('should support term search with one response', () => {
        globalSearch.searchFunctions[1].function = sinon.stub().resolves(undefined)
        svc = init()

        //given some mocks
        response1.entity.responseDescription.totalHits = 1
        searchItem1.responseHandler.withArgs(response1).returns(['response'])

        //when exactly one response is returned
        return svc.termSearch(term)
            .then(result => {
                //then it should call select handler
                searchItem1.selectHandler.should.have.been.calledWith('response', $state)
                should.not.exist(result)
            })
    })

    it('should support route to list', () => {
        //given some mocks
        $state.go = sinon.stub()
        let type = 'entity2'

        //when called
        svc.routeToList(type, term)

        //then route should happen
        $state.go.should.have.been.calledWith('list.route2', {q: term})
    })

    it('should get the key property', () => {
        let type = 'entity'

        let result = svc.getTypeTranslationKey(type)

        result.should.equal('typeTranslationKey')
    })

    it('should return an emtpy array when search item responsehandler returns nothing', () => {
        searchItem1.responseHandler = null

        return svc.typeAheadSearch(term)
            .then(result => {
                result.should.deep.equal([])
            })
    })

    it('should support term search when no keys are provided and total hits is 0', () => {
        let expectedResponse = _.clone(response1)
        globalSearch.searchFunctions[1].function = sinon.stub().resolves(undefined)
        svc = init()

        response1.entity.responseDescription.totalHits = 0
        searchItem1.responseHandler = null

        return svc.termSearch(term)
            .then(result => {
                //then it should call select handler
                result.should.deep.equal(expectedResponse)
            })
    })
})
