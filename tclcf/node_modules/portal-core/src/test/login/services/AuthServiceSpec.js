describe('AuthService', () => {
    let $analytics
    let $location
    let $rootScope
    let $q
    let tokenService
    let svc
    let authConfig
    let $log
    let Restangular
    let i18nService
    let titleService
    let auth0Lock
    let toastService

    beforeEach(() => {
        $analytics = {}

        $log = {}
        $log.error = sinon.stub()

        $rootScope = {}
        $rootScope.$broadcast = sinon.stub()

        $q = Promise

        auth0Lock = {}

        $location = {}
        $location.url = sinon.stub()

        i18nService = {}
        i18nService.getBrowserLocale = sinon.stub().returns('en-US')
        i18nService.updateCurrentLocale = sinon.stub().returns({then: sinon.stub().returnsThis()}).resolves({uid: 'uid', locale: 'en-US'})

        Restangular = {}
        Restangular.all = sinon.stub().returnsThis()
        Restangular.one = sinon.stub().returnsThis()
        Restangular.post = sinon.stub()
        Restangular.get = sinon.stub()
        Restangular.customPOST = sinon.stub()

        titleService = {}

        tokenService = {}
        tokenService.updateTokens = sinon.stub()
        tokenService.clear = sinon.stub()

        toastService = {}

        authConfig = {}

        let AuthService = require('../../../main/login/services/AuthService')
        svc = new AuthService($analytics, $log, $q, $location, $rootScope, auth0Lock, authConfig, i18nService,
            Restangular, titleService, toastService, tokenService)
    })

    it('should know if user is logged in', () => {
        svc.isLoggedIn().should.be.false

        svc.currentUser = 'abc'

        svc.isLoggedIn().should.be.true

        svc.currentUser = {anonymous: true}

        svc.isLoggedIn().should.be.false
    })

    it('should support OLD login', () => {
        let loginDetails = {login: true}
        let user = {uid: 'uid', grant: []}
        user.setLocale = sinon.stub().returns({then: sinon.stub().returnsThis()}).resolves({uid: 'uid', locale: 'en-US', grant: []})
        let tokens = {idToken: {uid: 'uid'}}
        Restangular.post.resolves(tokens)
        Restangular.get.resolves(user)
        $location.url.returns('/login')
        authConfig.requireLogin = true

        return svc.login(loginDetails)
            .then(result => {
                Restangular.post.should.have.been
                    .calledAfter(Restangular.all.withArgs('userLogin'))
                    .and.calledWith(loginDetails)

                tokenService.updateTokens.should.have.been.calledWith(tokens)

                Restangular.get.should.have.been
                    .calledAfter(Restangular.all.withArgs('users'))
                    .and.calledWith(tokens.idToken.uid)

                i18nService.getBrowserLocale.should.have.been.called

                user.setLocale.should.have.been.called

                i18nService.updateCurrentLocale.should.have.been.called

                $location.url.should.have.been.calledWith('/nav/welcome')
                $rootScope.$broadcast.should.have.been.calledWith('login')

                result.should.deep.equal({
                    uid: 'uid',
                    locale: 'en-US'
                })
            })
    })

    it('should support refreshing token', () => {
        let user = {uid: 'uid', locale: 'en-US', grant: []}
        let tokens = {idToken: {uid: 'uid'}, encodedToken: 'encTok'}
        Restangular.customPOST.resolves(tokens)
        Restangular.get.resolves(user)
        tokenService.getEncodedToken = sinon.stub().returns(tokens.encodedToken)

        return svc.refreshTokens()
            .then(result => {
                Restangular.customPOST.should.have.been
                    .calledAfter(Restangular.all.withArgs('refreshToken'))
                    .and.calledWith({encodedToken: tokens.encodedToken})

                Restangular.get.should.have.been
                    .calledAfter(Restangular.all.withArgs('users'))
                    .and.calledWith(tokens.idToken.uid)

                i18nService.getBrowserLocale.should.not.have.been.called

                i18nService.updateCurrentLocale.should.have.been.called

                result.should.deep.equal({
                    uid: 'uid',
                    locale: 'en-US'
                })
            })
    })

    it('should support refreshing token errors', () => {
        let tokens = {idToken: {uid: 'uid'}, encodedToken: 'encTok'}
        Restangular.customPOST.rejects('err')
        tokenService.getEncodedToken = sinon.stub().returns(tokens.encodedToken)

        return svc.refreshTokens()
            .catch(() => {
                Restangular.get.should.not.have.beencalled
                $log.error.should.have.been.called
                tokenService.clear.should.have.been.called
                $rootScope.$broadcast.should.have.been.calledWith('logout')
            })
    })

    it('should support logout', () => {
        return svc.logout()
            .then(() => {
                tokenService.clear.should.have.been.called
                $rootScope.$broadcast.should.have.been.calledWith('logout')
            })
    })

    it('should support logout with skip route', () => {
        return svc.logout(true)
            .then(() => {
                tokenService.clear.should.have.been.called
                $rootScope.$broadcast.should.have.been.calledWith('logout')
            })
    })

    it('should support token update with invalid token', () => {
        $location.url.withArgs().returns('/nav/url')

        return svc.tokenUpdated()
            .catch(err => {
                err.should.be.a.string
                $location.url.should.have.been.calledWith()
                $location.url.should.have.been.calledWith('/login')
            })
    })

    it('should support token update with invalid token already at login page', () => {
        $location.url.withArgs().returns('/login')

        return svc.tokenUpdated()
            .catch(err => {
                err.should.be.a.string
                $location.url.should.have.been.calledWith()
            })
    })

    describe('once user is loaded', () => {
        let user

        beforeEach(() => {
            user = {uid: 'uid', locale: 'en-US', grant: []}
            let tokens = {idToken: {uid: 'uid'}, encodedToken: 'encTok'}
            Restangular.customPOST.resolves(tokens)
            Restangular.get.resolves(user)
            tokenService.getEncodedToken = sinon.stub().returns(tokens.encodedToken)

            return svc.refreshTokens()
        })

        it('should resolve user', () => {
            return svc.getCurrentUser()
                .then(result => {
                    result.should.deep.equal({
                        grant: ['AUTHENTICATED'],
                        uid: 'uid',
                        locale: 'en-US'
                    })
                })
        })
    })
    
    describe('should redirect properly', () => {
        let token
        let user

        beforeEach(() => {
            token = {uid: 123}
            user = {locale: 'blah', grant: []}
            Restangular.all = sinon.stub().returnsThis()
            Restangular.get = sinon.stub().resolves(user)
            i18nService.updateCurrentLocale = sinon.stub()
            authConfig.requireLogin = true
        })

        it('should redirect from login with alternate url', () => {
            $location.url.returns('/login')
            svc.redirectUrl = '/nav/bloop'

            return svc.tokenUpdated(token, true)
                .then(() => {
                    $location.url.should.have.been.calledWith('/nav/bloop')
                })
        })

        it('should redirect from login with no url', () => {
            $location.url.returns('/login')

            return svc.tokenUpdated(token, true)
                .then(() => {
                    $location.url.should.have.been.calledWith('/nav/welcome')
                })
        })

        it('should not redirect when already on a page', () => {
            $location.url.returns('/nav/tardises')

            return svc.tokenUpdated(token, true)
                .then(() => {
                    $location.url.should.not.have.been.calledWith(sinon.match.string)
                })
        })

        it('when logged out but on a login-required page', () => {
            $location.url.returns('/nav/weebles')

            return svc.tokenUpdated(null).should.be.rejected
                .then(() => {
                    $location.url.should.have.been.calledWith('/login')
                    svc.redirectUrl.should.equal('/nav/weebles')
                })
        })

        it('when logged out but on a public page', () => {
            $location.url.returns('/blork')

            return svc.tokenUpdated(null).should.be.rejected
                .then(() => {
                    $location.url.should.not.have.been.calledWith(sinon.match.string)
                    should.not.exist(svc.redirectUrl)
                })
        })

        it('when url is empty', () => {
            $location.url.returns('')

            return svc.tokenUpdated(null).should.be.rejected
                .then(() => {
                    $location.url.should.have.been.calledWith('/login')
                    svc.redirectUrl.should.equal('')
                })
        })

        it('requireLogin=false and redirect=true while logged out', () => {
            authConfig.requireLogin = false

            return svc.tokenUpdated(null, true)
                .then(() => {
                    $location.url.should.not.have.been.calledWith(sinon.match.string)
                })
        })

        it('requireLogin=false and redirect=false while logged out', () => {
            authConfig.requireLogin = false

            return svc.tokenUpdated(null, false)
                .then(() => {
                    $location.url.should.not.have.been.calledWith(sinon.match.string)
                })
        })
    })
})
