describe('loginRouteConfig', () => {
    let $stateProvider
    let routeHelper

    beforeEach(() => {
        $stateProvider = {}
        $stateProvider.state = sinon.stub().returns($stateProvider)

        routeHelper = {}
        routeHelper.resolveCurrentUser = sinon.stub()
        routeHelper.currentUser = sinon.stub()
        
        sinon.stub(_, 'defer').callsArg(0)

        require('../../../main/loginNew/config/loginRouteConfig')($stateProvider, routeHelper)
    })
    
    afterEach(() => {
        _.defer.restore()
    })

    it('should provide routes', () => {
        $stateProvider.state.should.have.callCount(3)
        $stateProvider.state.should.have.been.calledWith('logout')
        $stateProvider.state.should.have.been.calledWith('auth')
        $stateProvider.state.should.have.been.calledWith('auth.login')
    })

    it('should fully log out during logout route when login required', () => {
        let $state = {}
        $state.go = sinon.stub()

        let authService = {}
        authService.logout = sinon.stub().resolves({})
        
        let authConfig = {requireLogin: true}

        let resolve = $stateProvider.state.withArgs('logout').getCall(0).args[1].resolve
        return resolve.logout($state, authConfig, authService)
            .then(() => {
                authService.logout.should.have.been.called
                $state.go.should.have.been.calledWith('auth.login')
            })
    })

    it('should fully log out during logout route when login isnt required', () => {
        let $state = {}
        $state.go = sinon.stub()

        let authService = {}
        authService.logout = sinon.stub().resolves({})

        let authConfig = {requireLogin: false}

        let resolve = $stateProvider.state.withArgs('logout').getCall(0).args[1].resolve
        return resolve.logout($state, authConfig, authService)
            .then(() => {
                authService.logout.should.have.been.called
                $state.go.should.have.been.calledWith('nav.welcome', null, {reload: true})
            })
    })
    
    it('should redirect on login for portals that do not require login', () => {
        let $state = {go: sinon.stub()}
        let authConfig = {requireLogin: false}
        
        let resolve = $stateProvider.state.withArgs('auth.login').getCall(0).args[1].resolve
        
        return resolve.login(Promise, $state, authConfig).should.be.rejected
            .then(() => {
                $state.go.should.have.been.calledWith('nav.welcome')
            })
    })

    it('should not redirect on login for portals that require login', () => {
        let $state = {go: sinon.stub()}
        let authConfig = {requireLogin: true}

        let resolve = $stateProvider.state.withArgs('auth.login').getCall(0).args[1].resolve

        resolve.login(Promise, $state, authConfig)

        $state.go.should.not.have.been.called
    })
})
