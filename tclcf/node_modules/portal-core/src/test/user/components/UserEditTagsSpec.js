describe('UserEditTags', () => {
    let component
    let ctrl
    let $log
    let $translate
    let translated
    let loadingService
    let toastService
    let user
    let $state

    beforeEach(() => {
        $log = {}

        translated = {translated: true}
        $translate = sinon.stub().resolves(translated)

        loadingService = {}
        loadingService.loading = sinon.stub()

        toastService = {}

        user = {}
        user.tags = []

        $state = {}
        _.set($state, '$current.locals.globals', {
            user
        })

        component = require('../../../main/user/components/UserEditTags')
        ctrl = new component.controller($log, $state, $translate, loadingService, toastService)
        ctrl.$onInit()
    })

    it('it should initialize', () => {
        user.tags = [
            'abc|def',
            'invalid',
            'ghi|jkl'
        ]

        ctrl.$onInit()

        ctrl.tags.should.deep.equal([
            {key: 'abc', value: 'def'},
            {key: 'ghi', value: 'jkl'}
        ])
    })

    it('it should handle addTag', () => {
        ctrl.newTagKey = 'kee'
        ctrl.newTagValue = 'vaa'
        user.save = sinon.stub().resolves({tags: ['existing|tag', 'kee|vaa']})

        return ctrl.addTag()
            .then(() => {
                user.save.should.have.been.called
                user.tags.should.deep.equal(['kee|vaa'])
                ctrl.tags.should.deep.equal([
                    {key: 'existing', value: 'tag'},
                    {key: 'kee', value: 'vaa'}
                ])
                ctrl.newTagKey.should.equal('')
                ctrl.newTagValue.should.equal('')
            })
    })

    it('it should handle editTag', () => {
        let tag = {key: 'kee', value: 'vaa'}
        ctrl.tags = [tag]
        user.tags = ['kee|vaa']

        ctrl.editTag(tag)

        ctrl.editingTag.should.equal(tag)
        ctrl.tags.should.deep.equal([])
        user.tags.should.deep.equal([])
        ctrl.newTagKey.should.equal('kee')
        ctrl.newTagValue.should.equal('vaa')
        ctrl.addingTag.should.be.true
    })

    it('it should handle removeTag', () => {
        let tag = {key: 'kee', value: 'vaa'}
        user.tags = ['kee|vaa']
        user.save = sinon.stub().resolves({})

        return ctrl.removeTag(tag)
            .then(() => {
                user.save.should.have.been.called
                user.tags.should.deep.equal([])
                ctrl.tags.should.deep.equal([])
            })
    })

    it('it should handle cancelEdit of an existing tag', () => {
        let tag = {key: 'kee', value: 'vaa'}
        ctrl.editingTag = tag
        ctrl.tags = []

        ctrl.cancelEdit()

        user.tags.should.deep.equal(['kee|vaa'])
        ctrl.tags.should.deep.equal([tag])
        should.not.exist(ctrl.editingTag)
        ctrl.newTagKey.should.equal('')
        ctrl.newTagValue.should.equal('')
    })

    it('it should handle cancelEdit of a new tag', () => {
        ctrl.newTagKey = 'kee'
        ctrl.newTagValue = 'vaa'
        ctrl.tags = []

        ctrl.cancelEdit()

        user.tags.should.deep.equal([])
        ctrl.tags.should.deep.equal([])
        should.not.exist(ctrl.editingTag)
        ctrl.newTagKey.should.equal('')
        ctrl.newTagValue.should.equal('')
    })

    it('it should handle save failures', () => {
        $log.error = sinon.stub()
        toastService.show = sinon.stub()
        user.save = sinon.stub().rejects({})

        ctrl.addTag()
            .then(() => {
                $log.error.should.have.been.called
                toastService.show.should.have.been.called
            })
    })
})
