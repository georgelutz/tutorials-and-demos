describe('userRestangularConfig', () => {
    let init
    let user
    let $log
    let Restangular
    let dialogService
    let toastService
    let event
    let $state
    let loadingService
    let $translate
    let $translateDefaultInterpolation

    beforeEach(() => {
        Restangular = {url: ''}
        Restangular.addElementTransformer = sinon.stub()
        Restangular.all = sinon.stub().returnsThis()
        Restangular.one = sinon.stub().returnsThis()
        Restangular.customPOST = sinon.stub()
        Restangular.customPUT = sinon.stub()
        Restangular.customGETLIST = sinon.stub()
        Restangular.get = sinon.stub().returnsThis()

        dialogService = {}
        dialogService.showConfirm = sinon.stub()
        dialogService.showConfirmDelete = sinon.stub()

        $log = {}
        $log.warn = sinon.stub()
        $log.error = sinon.stub()

        toastService = {}
        toastService.show = sinon.stub()

        user = {
            key: 'key',
            id: 'key',
            firstName: 'first',
            lastName: 'last'
        }

        $state = {}

        loadingService = {}
        loadingService.loading = sinon.stub()

        event = {event: true}

        $translate = (arr => Promise.resolve(arr.reduce((r, v) => {
            r[v] = v
            return r
        }, {})))

        $translateDefaultInterpolation = {}
        $translateDefaultInterpolation.interpolate = sinon.stub()

        init = () => {
            let constructor = require('../../../main/user/run/userRestangularConfig')
            constructor($log, $state, $translate, $translateDefaultInterpolation, Restangular, dialogService, toastService, loadingService)
            Restangular.addElementTransformer.getCall(0).args[2](user)
        }
        init()
    })

    it('should add a user element transformer', () => {
        Restangular.addElementTransformer.should.have.been.calledWith('users')
    })

    it('should have an addSubscribedTag method', () => {
        Restangular.customPOST.returns('abc')

        user.addSubscribedTag('tag').should.equal('abc')

        Restangular.customPOST.should.have.been.calledWith(null, 'add-subscribed-tag/key/tag')
            .and.calledAfter(Restangular.all.withArgs('users'))
    })

    it('should have an addTag method', () => {
        Restangular.customPOST.returns('abc')

        user.addTag('tag').should.equal('abc')

        Restangular.customPOST.should.have.been.calledWith(null, 'add-tag/key/tag')
            .and.calledAfter(Restangular.all.withArgs('users'))
    })

    it('should have a changeEmail method', () => {
        Restangular.customPOST.returns('abc')

        user.changeEmail('email@gmail.com').should.equal('abc')
        Restangular.customPOST.should.have.been.calledWith({
            emailAddress: {
                emailAddress: 'email@gmail.com',
                preferred: true
            },
            userId: user.id
        }, 'emailAddress/change')
    })

    it('should have a changePassword method', () => {
        Restangular.customPUT.returns('abc')
        let body = {body: true}

        user.changePassword(body).should.equal('abc')

        Restangular.all.should.have.been.calledWith('users')
        Restangular.customPUT.should.have.been.calledWith(body, `${user.id}/changePassword`)
    })

    it('should confirm deletes', () => {
        let deleteArgs = {
            entityName: `${user.firstName} ${user.lastName}`,
            targetEvent: event
        }
        dialogService.showConfirmDelete.withArgs(deleteArgs).resolves({})
        user.remove = sinon.stub().resolves({})
        let response = {}
        _.set(response, 'responseDescription.totalHits', 0)

        return user.confirmDelete(event)
            .then(() => {
                user.remove.should.have.been.called
                user.deleted.should.be.true
            })
    })

    it('should handle delete errors', () => {
        let deleteArgs = {
            entityName: `${user.firstName} ${user.lastName}`,
            targetEvent: event
        }
        dialogService.showConfirmDelete.withArgs(deleteArgs).resolves({})
        user.remove = sinon.stub().rejects('error')

        return user.confirmDelete(event)
            .then(() => {
                $log.error.should.have.been.called
                toastService.show.should.have.been.called
            })
    })

    it('should handle delete cancels', () => {
        let deleteArgs = {
            entityName: `${user.firstName} ${user.lastName}`,
            targetEvent: event
        }
        dialogService.showConfirmDelete.withArgs(deleteArgs).rejects(false)

        return user.confirmDelete(event)
            .then(() => {
                $log.error.should.not.have.been.called
                toastService.show.should.not.have.been.called
            })
    })

    it('should confirm email save', () => {
        $translateDefaultInterpolation.interpolate.returns('save_email_link')
        dialogService.showConfirm.resolves({})
        user.userEmails = ['email@gmail.com']
        user.submitEmail = sinon.stub().resolves({})

        return user.confirmSaveEmail(event)
            .then(() => {
                user.submitEmail.should.have.been.called
            })
    })

    it('should handle email save errors', () => {
        dialogService.showConfirm.resolves({})
        user.userEmails = ['email@gmail.com']
        user.submitEmail = sinon.stub().rejects('error')

        return user.confirmSaveEmail(event)
            .then(() => {
                $log.error.should.have.been.called
                toastService.show.should.have.been.called
            })
    })

    it('should handle email save cancels', () => {
        dialogService.showConfirm.rejects(false)
        user.userEmails = ['email@gmail.com']

        return user.confirmSaveEmail(event)
            .then(() => {
                $log.error.should.not.have.been.called
                toastService.show.should.not.have.been.called
            })
    })

    it('should have a getUserOrgTypes method', () => {
        Restangular.customGETLIST.returns('abc')

        user.getUserOrgTypes().should.equal('abc')

        Restangular.customGETLIST.should.have.been.calledWith('realms/OEM')
            .and.calledAfter(Restangular.all.withArgs('organizationTypes'))
    })

    it('should have a getUserPreferences method', () => {
        Restangular.get = sinon.stub().returns('abc')
        Restangular.one = sinon.stub().returnsThis()

        user.getUserPreferences().should.equal('abc')

        Restangular.get.should.have.been.calledAfter(Restangular.one.withArgs('userpreferences', user.id))
    })

    it('should have a getUserRolesType method: null orgId', () => {
        Restangular.customGETLIST.returns('abc')

        user.getUserRolesType('orgType12').should.equal('abc')

        Restangular.customGETLIST.should.have.been.calledWith('realms/OEM/orgType/orgType12')
            .and.calledAfter(Restangular.all.withArgs('roles'))
    })

    it('should have a getUserRolesType method: with orgId', () => {
        Restangular.customGETLIST.returns('abc')

        user.getUserRolesType('orgType12', 'orgId34').should.equal('abc')

        Restangular.customGETLIST.should.have.been.calledWith('realms/OEM/org/orgType12/orgId34')
            .and.calledAfter(Restangular.all.withArgs('roles'))
    })

    it('should have a canEditUser method: self', () => {
        let otherUser = {id: 'key'}
        user.canEditUser(otherUser).should.be.true
    })

    it('should warn when hasPermission is checked with ROLE_SERVER_ADMIN', () => {
        user.hasPermission('ROLE_SERVER_ADMIN')

        $log.warn.should.have.been.called
    })

    it('should have a canEditUser method: other, no permission', () => {
        user.hasPermission = sinon.stub().returns(false)
        let otherUser = {
            id: 'noKey',
            userOrganizations: []
        }

        user.canEditUser(otherUser).should.be.false
    })

    it('should have a canEditUser method: other, no orgs', () => {
        user.hasPermission = sinon.stub().returns(true)
        let otherUser = {
            id: 'noKey'
        }

        user.canEditUser(otherUser).should.be.false
    })

    it('should have a canEditUser method: other, has orgs', () => {
        user.hasPermission = sinon.stub().returns(true)
        let otherUser = {
            id: 'noKey',
            userOrganizations: [{organizationTypeId: 'org1'}, {organizationTypeId: 'org2'}]
        }

        user.canEditUser(otherUser).should.be.true
    })

    it('should have a canEditUser method: other, with permission', () => {
        let otherUser = {id: 'key'}
        user.canEditUser(otherUser).should.be.true
    })

    it('should have a hasPermission method: true', () => {
        user.grant = ['blah']
        user.hasPermission('blah').should.be.true
    })

    it('should have a hasPermission method: false', () => {
        user.grant = ['blarg']
        user.hasPermission('blah').should.be.false
    })

    it('should have a isOrgType method: user.orgType is equal', () => {
        user.orgType = 'ORG'
        user.isOrgType('ORG').should.be.true
    })

    it('should have a isOrgType method: user orgs contains value', () => {
        user.userOrganizations = [{
            organizationTypeId: 'ORG'
        }]

        user.isOrgType('ORG').should.be.true
    })

    it('should have a isOrgType method: false', () => {
        user.userOrganizations = [{
            organizationTypeId: 'GOV'
        }]

        user.isOrgType('ORG').should.be.false
    })

    it('should have a removeSubscribedTag method', () => {
        Restangular.customPOST.returns('abc')

        user.removeSubscribedTag('tag').should.equal('abc')

        Restangular.customPOST.should.have.been.calledWith(null, 'remove-subscribed-tag/key/tag')
            .and.calledAfter(Restangular.all.withArgs('users'))
    })

    it('should have a removeTag method', () => {
        Restangular.customPOST.returns('abc')

        user.removeTag('tag').should.equal('abc')

        Restangular.customPOST.should.have.been.calledWith(null, 'remove-tag/key/tag')
            .and.calledAfter(Restangular.all.withArgs('users'))
    })

    it('should have a submitEmail method: success', function(done) {
        user.userEmails = ['email@gmail.com']
        user.changeEmail = sinon.stub().resolves()

        user.submitEmail().then(() => {
            loadingService.loading.should.have.been.calledTwice
            toastService.show.should.have.been.called

            done()
        })
    })

    it('should handle failure in the submitEmail method', () => {
        user.userEmails = ['email@gmail.com']
        user.changeEmail = sinon.stub().rejects('error')

        return user.submitEmail().then(() => {
            loadingService.loading.should.have.been.called
            toastService.show.should.have.been.called
            $log.error.should.have.been.called
        })
    })

    it('should have a submitPassword method: success', () => {
        user.userEmails = ['email@gmail.com']
        user.changePassword = sinon.stub().resolves()

        return user.submitPassword().then(() => {
            loadingService.loading.should.have.been.calledTwice
            toastService.show.should.have.been.called
        })
    })

    it('should handle failure in the submitPassword method', () => {
        user.userEmails = ['email@gmail.com']
        user.changePassword = sinon.stub().rejects('error')

        return user.submitPassword().then(() => {
            loadingService.loading.should.have.been.called
            toastService.show.should.have.been.called
            $log.error.should.have.been.called
        })
    })

    it('should support set locale', () => {
        user.put = sinon.stub().resolves({})
        
        return user.setLocale('pt-BR').then(() => {
            user.locale.should.equal('pt-BR')
            user.put.should.have.been.called
        })
    })

    it('should support getTagByKey', () => {
        user.tags = ['someKey|someValue']

        user.getTagByKey('someKey').should.equal('someValue')
    })

    it('should support getTagByKey when tags are empty', () => {
        user.tags = ['']

        user.getTagByKey().should.equal('')
    })

    it('should not set the user key if no user id is provided', () => {
        user.id = undefined

        init()
        should.equal(user.key, 'key')
    })
})
